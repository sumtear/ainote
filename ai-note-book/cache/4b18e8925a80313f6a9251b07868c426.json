{
  "timestamp": 1742363926.0574534,
  "result": "# MySQL InnoDB 选择 B+Tree 作为索引数据结构的原因\n\n## B+Tree vs B Tree\n### 数据存储位置\n- B+Tree 只在叶子节点存储数据\n- B 树的非叶子节点也要存储数据\n\n### 节点数据量\n- B+Tree 的单个节点数据量更小\n- 在相同的磁盘 I/O 次数下，B+Tree 能查询更多的节点\n\n### 范围查询\n- B+Tree 叶子节点采用双链表连接\n- 适合 MySQL 中常见的基于范围的顺序查找\n- B 树无法做到这一点\n\n## B+Tree vs 二叉树\n### 搜索复杂度\n- B+Tree 的搜索复杂度为 O(logdN)，其中 d 表示节点允许的最大子节点个数\n- 二叉树的搜索复杂度为 O(logN)\n\n### 树的高度\n- B+Tree 的高度通常维持在 3~4 层\n- 即使数据达到千万级别，B+Tree 的高度依然较低\n- 二叉树的高度较高，导致磁盘 I/O 次数更多\n\n## B+Tree vs Hash\n### 查询效率\n- Hash 表在等值查询时效率极高，搜索复杂度为 O(1)\n- B+Tree 在范围查询时表现更优\n\n### 适用场景\n- Hash 表不适合做范围查询\n- B+Tree 索引适用于更广泛的场景，包括等值查询和范围查询\n\n通过以上对比，可以看出 B+Tree 在数据存储、搜索复杂度、树的高度以及适用场景等方面具有明显优势，因此 MySQL InnoDB 选择 B+Tree 作为索引的数据结构。"
}